# 2020年第5周 2020.01.26 - 2020.02.02

&emsp;&emsp;2020年开年第一篇ARTS写写总结，新的一年，

## Algorithm

&emsp;&emsp;LeetCode刷题，二分查找算法思想总结：
- 1、查找值
- 2、查找左区间
- 3、查找右区间

> 待补充。。。


## Review

> 待补充。。。

## Tip

### 系统的高可用建设
> - 架构阶段：
>> - 异地容灾
>> - 异步化
>> - 分组隔离
>> - 避免单点

> - 编码阶段：
>> - 限流保护
>> - 超时处理！！！
>> - 异步线程
>> - 错误捕获

> - 测试阶段：
>> - beta测试
>> - 自动化对比测试

> - 发布阶段：
>> - 分批发布
>> - 多版本发布

> - 运行阶段：
>> - 数据对账
>> - 自动降级
>> - 过载保护
>> - 实时监控报警

> - 故障发生：
>> - 快速恢复
>> - 故障定位

## Share
### &emsp;&emsp;流量削峰的一些操作思路：其中无损（即不会损失用户发出请求）的实现方案有：排队、答题、分层过滤。而有损的实现方案有：限流、机器负载保护等一些强制措施也能达到削峰保护的目的，但这都是不得已的一些措施。
> - 1、**排队：** 消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送。这里的消息队列就像“水库”一样，拦蓄上游的洪水，消减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。
>> &emsp;&emsp;常见的排队方式还有：线程池加锁等待；先进先出、先进后出等常用的内存排队算法的实现方式；以及把请求序列化到文件中，然后再顺序地读文件（例如基于MySQL binlog的同步机制）来恢复请求的方式。

> - 2、**答题：** 弹窗，然后让用户答题或者滑一滑操作；防止秒杀器的同时，还能延缓请求，把峰值的下单请求拉长。而且由于请求有先后顺序，靠后的请求到来时自然就没有库存了，因此根本到不了最后下单的步骤，所以真正的并发写就非常有限。

> - 3、**分层过滤：** 分层过滤核心思想是：在不同的层次尽可能地过滤掉无效请求，如“漏斗过滤”式的，最末端的才是最有效的请求。而要达到这种效果，我们就必须对数据进行分层校验。
>> &emsp;&emsp;分层校验的基本原则是：将动态请求的读数据缓存（cache）在Web端，过滤掉无效的数据读；对写数据进行基于时间过滤掉过期的失效请求；对写数据进行强一致性的校验，只保留最后有效的数据。
