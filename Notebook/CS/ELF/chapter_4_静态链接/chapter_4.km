{
    "root": {
        "data": {
            "id": "cg0kuxyzg140",
            "created": 1638017828220,
            "text": "第四章、静态链接",
            "note": "本章我们首先介绍了静态链接中的第一个步骤，即目标文件在被链接成最终可执行文件时，输入目标文件中的各个段是如何被合并到输出文件中的，链接器如何 为它们分配在输出文件中的空间和地址。一旦输入段的最终地址被确定，按下来就可以进行行号的解祈与重定位，链接器会把各个输入目标文件中对于外部符号的引1用进行解析，把每个段中须重定位的指令和数据进行 “修补”，使它们都指向正确的位直。\n\n在本章里，我们还对几个静态链接中的问题进行了分析，比如为什么未初始化的全局静态变量要使用 COMMON 块、C++会对链接器和目标文件有什么样的要求、如何使用脚本控制链接过程使得输出的可执行文件能够满足某些特殊的需求，比如不使用默认C语言运行库的程序、运行于联入式系统的程序，甚至是操作系统内核、驱动程序，等等。"
        },
        "children": [
            {
                "data": {
                    "id": "cg0kv6ou8f40",
                    "created": 1638017847198,
                    "text": "4.1、空间与地址分配"
                },
                "children": [
                    {
                        "data": {
                            "id": "cg0l0x492200",
                            "created": 1638018296547,
                            "text": "4.1.1、按序叠加",
                            "note": "最简单的方案是将输入的一个或多个目标文件的各个段（.text, .data, .bss等段）按次序叠加起来。"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0l32cy9680",
                            "created": 1638018464685,
                            "text": "4.1.2、相似度合并（两步链接Two-pass Linking）",
                            "note": "第一步 空间与地址分配：扫描所有的输入目标文件，获得它们的各个段的长度、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局行号表。这一步中，链接器将能获得所有输入目标文件的段长度，并且将它们合并，计算出输出文件中各个段合并后的长度与位置，链接器将能够获得所有输入目标文件的段长度，并且将它们合并建立映射关系。\n\n第二步 符号解析与重定位：使用上面第一步中收集到的所有信息，读取输入文件中段的数据、重定位信息，并且进行行号解析与重定位、调整代码中的地址等。事实上第二步是链接过程的核心，特别是重定位过程。"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cg0l4demj2w0",
                                    "created": 1638018567095,
                                    "text": "第一步：空间与地址分配"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cg0l4juuc4w0",
                                    "created": 1638018581136,
                                    "text": "第二步：符号解析与重定位"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cg0l62hyvu80",
                            "created": 1638018700081,
                            "text": "4.1.3、符号地址段确定"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cg0l6bkpe8o0",
                                    "created": 1638018719837,
                                    "text": "链接器更新全局符号表中的符号地址"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cg0kvfmndw00",
                    "created": 1638017866656,
                    "text": "4.2、符号解析与重定位"
                },
                "children": [
                    {
                        "data": {
                            "id": "cg0l6shy7ww0",
                            "created": 1638018756676,
                            "text": "4.2.1、重定位*",
                            "note": "在完成空间和地址段分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。\n"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0lo5l0i000",
                            "created": 1638020117350,
                            "text": "4.2.2、重定位表"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0lqk7h66o0",
                            "created": 1638020305912,
                            "text": "4.2.3、符号解析"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0lrueno2w0",
                            "created": 1638020406478,
                            "text": "4.2.4、指令修正方式"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cg0ls4gtzrc0",
                                    "created": 1638020428377,
                                    "text": "a、近址寻址或远址寻址；\nb、绝对寻址或相对寻址；\nc、寻址长度为8位、16位、32位、64位。\n\n但是对于32位x86平台下的ELF文件的重定位入口所修正的指令寻址方式只有两种：\na、绝对近址32位寻址；\nb、相对近址32位寻址。"
                                },
                                "children": []
                            }
                        ]
                    }
                ]
            },
            {
                "data": {
                    "id": "cg0kvn29twg0",
                    "created": 1638017882838,
                    "text": "4.3、COMMON块"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cg0kvtc86cg0",
                    "created": 1638017896501,
                    "text": "4.4、C++相关问题"
                },
                "children": [
                    {
                        "data": {
                            "id": "cg0lw75l3nk0",
                            "created": 1638020747684,
                            "text": "4.4.1、重复代码消除（模板、外部内联函数和虚函数表都有可能在不同编译单元里生成相同的代码）"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cg0lxj3wfz40",
                                    "created": 1638020852068,
                                    "text": "函数级别链接"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cg0lxn93z200",
                            "created": 1638020861090,
                            "text": "4.4.2、全局构造与析构"
                        },
                        "children": [
                            {
                                "data": {
                                    "id": "cg0ly8z4a140",
                                    "created": 1638020908375,
                                    "text": ".init段（该段保存着进程初始化的代码指令。main函数被调用之前，Glibc的初始化部分安排执行这个段的代码）"
                                },
                                "children": []
                            },
                            {
                                "data": {
                                    "id": "cg0lza0i5sg0",
                                    "created": 1638020989000,
                                    "text": ".fini段（该段保存着进程终止代码指令。main函数正常退出时，Glibc会安排执行这个段中的代码）"
                                },
                                "children": []
                            }
                        ]
                    },
                    {
                        "data": {
                            "id": "cg0m0slbpog0",
                            "created": 1638021107805,
                            "text": "4.4.3、C++与ABI",
                            "note": "C++与 ABI\n既然每个编译器都能将源代码编译成目标文件，那么有没有不同编译器编译出来的目标文件是不能够相互链接的呢？ 有没有可能将MSVC编译出来的目标文件和GCC编译出来的目标文件链接到一起，形成一个可执行文件呢？\n\n对于上面这些问题，首先我们可以想到的是，如果要将两个不同编译器的编译结果链接到一起，那么，首先链接器必须支持这两个编译器产生的目标文件的格式。比如 MSVC编译的目标文件是PE/COEF格式的，而 GCC 编译的结果是 ELF格式的，链接器必须同时以识这两种格式才行，否则肯定没戏。那是不是链接器只要同时认识目标交件的格式就可以了呢？\n\n事实并不像我们想象的那么简单，如果要使两个编译器编译出来的目标文件能够相互链接，那么这两个目标文件必须满足下面这些条件：采用同样的目标文件格式、拥有同样的符号修饰标准、变量的内存分布方式相同、函数的调用方式相同，等等。其中我们把符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容称为 ABI(Application Binary Interface)。\n\nABI & API\n很多时候我们会碰到 API ( Application Programming Interface ） 这个概念，它与 ABI只有一字之差，而且非常类似，很多人经常将它们的概念搞混。那么它们之间有什么区别呢？实际上它们都是所谓的应用程序接口，只是它们所描述的接口所在的层面不一样。\nAPI 往往是指源代码级别的接口，比如我们可以说POSIX 是一个 API 标淮、Windows 所规定的应用程序接口是一个 AP)，而ABI 是指二进制层面的接口，ABI的兼容程度比 API 要更为严格，比如我们可以说C++的对象内存分布( Object Memory Layout )是C++ABI 的一部分。API更关注源代码层面的，比如 POSIX 规定 printf()这个函数原型。"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cg0kw0oa5g00",
                    "created": 1638017912467,
                    "text": "4.5、静态库链接",
                    "note": "一个静态链接库可以简单地看成一组目标文件的集合。"
                },
                "children": []
            },
            {
                "data": {
                    "id": "cg0kw8nlun40",
                    "created": 1638017929841,
                    "text": "4.6、链接过程控制"
                },
                "children": [
                    {
                        "data": {
                            "id": "cg0ma55iahs0",
                            "created": 1638021840424,
                            "text": "4.6.1、链接控制脚本"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0mcl1plcw0",
                            "created": 1638022031752,
                            "text": "4.6.2、最“小”的程序（见样例代码 TinyHelloWorld.c）"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0mo7gv6rk0",
                            "created": 1638022942564,
                            "text": "4.6.3、使用ld链接脚本（见样例链接脚本TinyHelloWorld.lds）"
                        },
                        "children": []
                    },
                    {
                        "data": {
                            "id": "cg0n0hpipso0",
                            "created": 1638023905224,
                            "text": "4.6.4、ld链接脚本语法简介"
                        },
                        "children": []
                    }
                ]
            },
            {
                "data": {
                    "id": "cg0kweb1h6w0",
                    "created": 1638017942142,
                    "text": "4.7、BFD库",
                    "note": "BFD 库\n由于现代的硬件和软件平合种类非常繁多，它们之间千差万別，比如，硬件中CPU 有8位的、16位的，一直到 64 位的：字节序有大端的也有小端的：有些有 MMU 有些没有，有些对访问内存地址对齐有着特殊要求，比如MIPS，而有些则没有，比x86。软件平台有些支持动态链接，而有些不支持；有些支持调试，有些又不支持。这些五花八门的软硬件平合基础导致了每个平合都有它独特的目标文件格式。即使同一个格式比如 ELF 在不同的软硬件平合都有着不同的变种。种种差异导致编译器和链接器很难处理不同平合之间的目标文件，特别是对于像 GCC 和binutils 这种跨平台的工具来说，最好有一种统一的接口来处理这些不同格式之间的差异。\n\nBFD 库 (Binary File Descriptor library）就是这样的一个 GNU 项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件格式。BFD 这个项目本身是binutis 项目的一个子项目。BFD 把目标文件抽象成一个统一的模型，比如在这个抽象的目标文件模型中，最开始有一个描述整个目标文件总体信息的“文件头”，就跟我们实际的 ELF 文件一样，文件头后面是一系列的段，每个段都有名字、属性和段的内容，同时还抽象了符号表、重定位表、宇符串表等类似的概念，使得 BFD 库的程序只要通过操作这个抽象的目标文件模型就可以实现操作所有 BFD 支持的目标文件格式现在 GCC（更具体地讲是 GNU 汇编器 GAS,GNU Assembler )、链接器 ld、调试器GDB 及binutils 的其他工具都通过 BFD库来处理目标文件，而不是直接操作目标文件。这样做最大的好处是将编译器和链接器本身同具体的目标文件格式隔离开来，一旦我们须要支持一种新的目标文件格式，只须要在 BFD 库里面添加一种格式就可以了，而不须要修改编译器和链接器。到目前为止，BFD 库支持大约 25种处理器平台，将近 50种目标文件格式。"
                },
                "children": []
            }
        ]
    },
    "template": "right",
    "theme": "fresh-blue",
    "version": "1.4.43"
}