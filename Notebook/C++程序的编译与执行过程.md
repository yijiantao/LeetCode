# C++ 程序的编译与执行过程

## 编译和执行过程
- 1、编译（预处理 -> 编译 -> 目标文件）；
  - 预处理：加载 "#include<头文件>" 形成 *.ii **预处理文件** ，执行命令为 "g++ -o test.ii -E test.cpp" ；
  - 编译：将 *.ii 文件编译成 *.s **汇编文件** ，执行命令为 "g++ -o test.s -S test.ii" ；
  - 形成目标代码/文件。目标代码是编译器的输出结果，是 *.o **二进制文件** ，常见扩展名为".o"或".obj"。执行命令为 "g++ -o test.o -c test.s"；

- 2、连接
  - 目标代码跟C++函数库相连接，并将源程序所用的库代码与目标代码合并。执行命令为 "g++ -o test.exe test.o"；
    - 静态连接文件：
    - 动态连接文件：
  - 形成最终可执行的二进制机器代码（可执行程序）；

- 3、执行
  - 在特定的机器环境下运行C++应用程序。
  

## 指针

&emsp;&emsp;指针是一个值为内存地址的变量（或数据对象）
### 指针变量
&emsp;&emsp;

### 指针和引用
&emsp;&emsp;指针和应用两者之间的关系：
> - 引用对指针进行了简单封装，底层仍然是指针；
> - 获取引用地址时，编译器会进行内部转换(类似给地址取了别名)。例如如下：

```C
int num = 100;
int& rel_num = num;    // 编译器在执行时，会将这一步在内部转换成： int* rel_num = &num;
rel_num = 110;         // 编译器在执行时，会将这一步在内部转换成： *rel_num = 110;
cout << &num << '\t' << &rel_num << endl;
```

### 堆内存，栈内存
&emsp;&emsp;栈区内存系统管理，读写速度快，只是发送指令？堆区内存程序员分配与释放管理？是执行指令具体步骤？例如：
```C
int num = 10;    // 栈区
// 而实际上在堆区需要执行以下两步操作：
int * p = new int;    // 堆区
*p = 90;        // 堆区
```

### 指针操作数组
&emsp;&emsp;

## 程序的内存分配
### 栈区（stack）
- 由编译器自动分配释放，一般存放函数的参数值、局部变量的值等；
- 操作方式类似数据结构中的栈-先进后出；

### 堆区（heap）
- 一般由程序员分配释放，若程序不释放，程序结束时间可能由操作系统回收；
- 注意：与数据结构中的堆是两回事，分配方式类似于链表；

### 全局区（静态区 static）
- 全局变量和静态变量是存储在一起的；
- 程序结束后由系统释放；

### 文字常量区
- 常量字符串就放在这里，程序结束后由系统释放。

### 程序代码区
- 存放函数体的二进制代码

```C
int num1 = 0;    // 全局初始化区
int * ptr1;    // 全局未初始化区
int main()
{
  
  int num2;    // 栈区
  char str[] = "yijiantao";    // 栈区
  char * ptr2;    // 栈区
  char * ptr3 = "yijiantao";    // "yijiantao"以及'\0'在常量区，ptr3在栈区

  static int num3 = 1024;    // 全局（静态）初始化区

  ptr1 = new int[10];    //分配内存在堆区
  ptr2 = new char[20];    //分配内存在堆区
  // 注意：ptr1和ptr2变量本身是在栈区中的，只不过把堆区中的地址赋值给了栈区中的变量

  return 0;
}
```


## 函数
### 函数指针
&emsp;&emsp;

### 内联函数
&emsp;&emsp;

### 参数的引用传递（重点）
&emsp;&emsp;

### 默认参数
&emsp;&emsp;

### 函数重载（重点）
&emsp;&emsp;

### 函数模板（难点）
&emsp;&emsp;