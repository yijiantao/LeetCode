# C++ 程序的编译与执行过程

## 编译和执行过程
- 1、编译（预处理 -> 编译 -> 目标文件）；
  - 预处理：加载 "#include<头文件>" 形成 *.ii **预处理文件** ，执行命令为 "g++ -o test.ii -E test.cpp" ；
  - 编译：将 *.ii 文件编译成 *.s **汇编文件** ，执行命令为 "g++ -o test.s -S test.ii" ；
  - 形成目标代码/文件。目标代码是编译器的输出结果，是 *.o **二进制文件** ，常见扩展名为".o"或".obj"。执行命令为 "g++ -o test.o -c test.s"；

- 2、连接
  - 目标代码跟C++函数库相连接，并将源程序所用的库代码与目标代码合并。执行命令为 "g++ -o test.exe test.o"；
    - 静态连接文件：
    - 动态连接文件：
  - 形成最终可执行的二进制机器代码（可执行程序）；

- 3、执行
  - 在特定的机器环境下运行C++应用程序。
  

## 指针

&emsp;&emsp;指针是一个值为内存地址的变量（或数据对象）
### 指针变量
&emsp;&emsp;

### 指针和引用
&emsp;&emsp;指针和应用两者之间的关系：
> - 引用对指针进行了简单封装，底层仍然是指针；
> - 获取引用地址时，编译器会进行内部转换(类似给地址取了别名)。例如如下：

```C
int num = 100;
int& rel_num = num;    // 编译器在执行时，会将这一步在内部转换成： int* rel_num = &num;
rel_num = 110;         // 编译器在执行时，会将这一步在内部转换成： *rel_num = 110;
cout << &num << '\t' << &rel_num << endl;
```

### 堆内存，栈内存
&emsp;&emsp;栈区内存系统管理，读写速度快，只是发送指令？堆区内存程序员分配与释放管理？是执行指令具体步骤？例如：
```C
int num = 10;    // 栈区
// 而实际上在堆区需要执行以下两步操作：
int * p = new int;    // 堆区
*p = 90;        // 堆区
```

### 指针操作数组
&emsp;&emsp;

## 程序的内存分配
### 栈区（stack）
- 由编译器自动分配释放，一般存放函数的参数值、局部变量的值等；
- 操作方式类似数据结构中的栈-先进后出；

### 堆区（heap）
- 一般由程序员分配释放，若程序不释放，程序结束时间可能由操作系统回收；
- 注意：与数据结构中的堆是两回事，分配方式类似于链表；

### 全局区（静态区 static）
- 全局变量和静态变量是存储在一起的；
- 程序结束后由系统释放；

### 文字常量区
- 常量字符串就放在这里，程序结束后由系统释放。

### 程序代码区
- 存放函数体的二进制代码

```C
int num1 = 0;    // 全局初始化区
int * ptr1;    // 全局未初始化区
int main()
{
  
  int num2;    // 栈区
  char str[] = "yijiantao";    // 栈区
  char * ptr2;    // 栈区
  char * ptr3 = "yijiantao";    // "yijiantao"以及'\0'在常量区，ptr3在栈区

  static int num3 = 1024;    // 全局（静态）初始化区

  ptr1 = new int[10];    //分配内存在堆区
  ptr2 = new char[20];    //分配内存在堆区
  // 注意：ptr1和ptr2变量本身是在栈区中的，只不过把堆区中的地址赋值给了栈区中的变量

  return 0;
}
```


## 函数
### 函数指针
&emsp;&emsp;

### 内联(inline)函数
&emsp;&emsp;是C++为提高程序运行速度所做的一项**改进；** 与常规函数的区别在于编译器使用函数代码替换函数调用；

&emsp;&emsp;内联(inline)函数如果调用N次，则会复制N个副本；而普通函数调用N次，也只在堆区存在一次，多个函数调用（函数地址）而已。

&emsp;&emsp;适用场景：类的存储等；

&emsp;&emsp;内联(inline)函数定义（关键字：inline）与调用方式如下：
```C
inline void show()
{
  cout << "yijiantao";
}

int main()
{
  show();    // 内联函数show()在调用时，等效于直接将show()函数里所有的语句复制于此；
  ///在这里show()等效于将cout << "yijiantao";语句复制于此
  return 0;
}
```
&emsp;&emsp;使用建议：如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。通常内联函数的执行时间是要求要比普通函数执行速度快的，一般内联函数代码非常简单明了，不能含有递归调用等；**如果代码执行时间很短，内联调用就可以节省大部分时间。** 

### 参数的引用传递（重点）
#### 引用（reference）
- 为对象起了另外一个名字（引用即别名）；
```C
int int_value = 1024;

int& refValue = int_value;    // refValue指向int_value，是int_value的另一个名字

int& refValue2;    // 错误：引用必须被初始化

int& refValue3 = 1024;    // 错误：不可以直接引用常量(字面量)

const int& refValue4 = 1024;    // 正确，指向常量的引用 - 合法；因为常量的基本概念是

```

&emsp;&emsp;注意：
- 1、引用并非对象，只是为了一个已经存在的对象起的别名；
- 2、引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起；
  - 例如：int& refValue3 = 1024;    // 错误
- 3、引用必须初始化，所以使用引用之前不需要测试其有效性，**因此使用引用可能会比使用指针效率高。** 
- 4、引用更接近const指针，一旦与某个变量关联起来，就将一直效忠于它；
- 5、将引用变量用作参数时，函数将使用原始数据，而非副本；
- 6、当数据所占内存比较大时，建议使用引用参数；

#### 使用引用参数

- 详见../LeetCode Algorithms/test.cpp代码中Swap()和Show()函数示例；

#### 返回引用类型
&emsp;&emsp;函数返回引用类型
- 1、不要返回局部变量的引用；(因为局部变量有生命周期)。如下代码：
- 2、函数可以不返回值，默认返回传入的引用对象本身；
- 3、返回引用时，要求函数参数中包含被返回的引用对象。
```C
int& sum()    // 返回引用类型的函数
{
    int num = 10;

    // 注意：rNum是在sum()函数中定义的，所以叫局部变量
    // rNum的生存期只在sum()函数中;
    int& rNum = num;

    // 函数中的局部变量会被内存回收
    // 所谓的内存回收，并不是把内存保存的设置清零
    // 而是指内存中你的程序申请的这块内存已经不是这个变量了！
    return rNum; // 返回了一个局部的引用类型变量 （禁止！绝对不要返回局部变量的引用！）
}
void test()
{
  int x = "占内存变量1";
  int y = "占内存变量2";
  int z = "占内存变量3";
}
int main()
{
  // result在这里引用了一个局部变量
  int& result = sum();
  test();    // 调用其他函数，注意这里会分配内存，有可能会分配到将局部变量引用释放掉后的内存
  cout << "result = " << result << endl;
  return 0;
}
```

#### **函数返回引用类型建议：** 
- 1、将返回类型修改为const int&
    const int& sum(int& num){……}
- 2、const类型为不可修改的左值，sum(num) = 1024 将函数再赋值时将不合法，编译不通过；
- 3、省略const会使函数的含义更加模糊，建议避免在设计函数中存在模糊的情况，因为模糊会增加犯错误的机会，应尽量避免犯错。
    const int& sum(const int& num){……}


#### **使用引用参数的一些指导原则：** 
- 1、能够修改调用函数中的数据对象；
- 2、数据对象较大时传递引用可以提高程序运行效率；
    - 2.1 函数中不需要修改传递的参数：
      - 如果数据对象很小，建议按值传递；
      - 传递数组只能使用指针，并使用const关键字；
      - 较大的对象则使用const指针或引用，以提高程序的效率。
      
    - 2.2 函数中需要修改传递的参数时：
      - 数据对象是基本类型或结构时，可以使用指针或引用（基本类型建议使用指针）；
      - 数据对象是数组时只能使用指针；
      - 数据对象是类对象时，要求使用引用。

### 默认参数
&emsp;&emsp;

### 函数重载（重点）
&emsp;&emsp;

### 函数模板（难点）
&emsp;&emsp;