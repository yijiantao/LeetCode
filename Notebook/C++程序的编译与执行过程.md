# C++ 程序的编译与执行过程

## 编译和执行过程
- 1、编译（预处理 -> 编译 -> 目标文件）；
  - 预处理：加载 "#include<头文件>" 形成 *.ii **预处理文件** ，执行命令为 "g++ -o test.ii -E test.cpp" ；
  - 编译：将 *.ii 文件编译成 *.s **汇编文件** ，执行命令为 "g++ -o test.s -S test.ii" ；
  - 形成目标代码/文件。目标代码是编译器的输出结果，是 *.o **二进制文件** ，常见扩展名为".o"或".obj"。执行命令为 "g++ -o test.o -c test.s"；

- 2、连接
  - 目标代码跟C++函数库相连接，并将源程序所用的库代码与目标代码合并。执行命令为 "g++ -o test.exe test.o"；
    - 静态连接文件：
    - 动态连接文件：
  - 形成最终可执行的二进制机器代码（可执行程序）；

- 3、执行
  - 在特定的机器环境下运行C++应用程序。
  

## 指针

&emsp;&emsp;指针是一个值为内存地址的变量（或数据对象）
### 指针变量
&emsp;&emsp;

### 指针和引用
&emsp;&emsp;指针和应用两者之间的关系：
> - 引用对指针进行了简单封装，底层仍然是指针；
> - 获取引用地址时，编译器会进行内部转换(类似给地址取了别名)。例如如下：

```C
int num = 100;
int& rel_num = num;    // 编译器在执行时，会将这一步在内部转换成： int* rel_num = &num;
rel_num = 110;         // 编译器在执行时，会将这一步在内部转换成： *rel_num = 110;
cout << &num << '\t' << &rel_num << endl;
```

### 堆内存，栈内存
&emsp;&emsp;栈区内存系统管理，读写速度快，只是发送指令？堆区内存程序员分配与释放管理？是执行指令具体步骤？例如：
```C
int num = 10;    // 栈区
// 而实际上在堆区需要执行以下两步操作：
int * p = new int;    // 堆区
*p = 90;        // 堆区
```

### 指针操作数组
&emsp;&emsp;

## 程序的内存分配
### 栈区（stack）
- 由编译器自动分配释放，一般存放函数的参数值、局部变量的值等；
- 操作方式类似数据结构中的栈-先进后出；

### 堆区（heap）
- 一般由程序员分配释放，若程序不释放，程序结束时间可能由操作系统回收；
- 注意：与数据结构中的堆是两回事，分配方式类似于链表；

### 全局区（静态区 static）
- 全局变量和静态变量是存储在一起的；
- 程序结束后由系统释放；

### 文字常量区
- 常量字符串就放在这里，程序结束后由系统释放。

### 程序代码区
- 存放函数体的二进制代码

```C
int num1 = 0;    // 全局初始化区
int * ptr1;    // 全局未初始化区
int main()
{
  
  int num2;    // 栈区
  char str[] = "yijiantao";    // 栈区
  char * ptr2;    // 栈区
  char * ptr3 = "yijiantao";    // "yijiantao"以及'\0'在常量区，ptr3在栈区

  static int num3 = 1024;    // 全局（静态）初始化区

  ptr1 = new int[10];    //分配内存在堆区
  ptr2 = new char[20];    //分配内存在堆区
  // 注意：ptr1和ptr2变量本身是在栈区中的，只不过把堆区中的地址赋值给了栈区中的变量

  return 0;
}
```


## 函数
### 函数指针
&emsp;&emsp;

### 内联(inline)函数
&emsp;&emsp;是C++为提高程序运行速度所做的一项**改进；** 与常规函数的区别在于编译器使用函数代码替换函数调用；

&emsp;&emsp;内联(inline)函数如果调用N次，则会复制N个副本；而普通函数调用N次，也只在堆区存在一次，多个函数调用（函数地址）而已。

&emsp;&emsp;适用场景：类的存储等；

&emsp;&emsp;内联(inline)函数定义（关键字：inline）与调用方式如下：
```C
inline void show()
{
  cout << "yijiantao";
}

int main()
{
  show();    // 内联函数show()在调用时，等效于直接将show()函数里所有的语句复制于此；
  ///在这里show()等效于将cout << "yijiantao";语句复制于此
  return 0;
}
```
&emsp;&emsp;使用建议：如果执行函数代码的时间比处理函数调用机制的时间长，则节省的时间将只占整个过程的很小一部分。通常内联函数的执行时间是要求要比普通函数执行速度快的，一般内联函数代码非常简单明了，不能含有递归调用等；**如果代码执行时间很短，内联调用就可以节省大部分时间。** 

### 参数的引用传递（重点）
#### 引用（reference）
- 为对象起了另外一个名字（引用即别名）；
```C
int int_value = 1024;

int& refValue = int_value;    // refValue指向int_value，是int_value的另一个名字

int& refValue2;    // 错误：引用必须被初始化

int& refValue3 = 1024;    // 错误：不可以直接引用常量(字面量)

const int& refValue4 = 1024;    // 正确，指向常量的引用 - 合法；因为常量的基本概念是

```

&emsp;&emsp;注意：
- 1、引用并非对象，只是为了一个已经存在的对象起的别名；
- 2、引用只能绑定在对象上，不能与字面值或某个表达式的计算结果绑定在一起；
  - 例如：int& refValue3 = 1024;    // 错误
- 3、引用必须初始化，所以使用引用之前不需要测试其有效性，**因此使用引用可能会比使用指针效率高。** 
- 4、引用更接近const指针，一旦与某个变量关联起来，就将一直效忠于它；
- 5、将引用变量用作参数时，函数将使用原始数据，而非副本；
- 6、当数据所占内存比较大时，建议使用引用参数；

#### 使用引用参数

- 详见../LeetCode Algorithms/test.cpp代码中Swap()和Show()函数示例；

#### 返回引用类型
&emsp;&emsp;函数返回引用类型
- 1、不要返回局部变量的引用；(因为局部变量有生命周期)。如下代码：
- 2、函数可以不返回值，默认返回传入的引用对象本身；
- 3、返回引用时，要求函数参数中包含被返回的引用对象。
```C
int& sum()    // 返回引用类型的函数
{
    int num = 10;

    // 注意：rNum是在sum()函数中定义的，所以叫局部变量
    // rNum的生存期只在sum()函数中;
    int& rNum = num;

    // 函数中的局部变量会被内存回收
    // 所谓的内存回收，并不是把内存保存的设置清零
    // 而是指内存中你的程序申请的这块内存已经不是这个变量了，会被覆盖的！
    return rNum; // 返回了一个局部的引用类型变量 （禁止！绝对不要返回局部变量的引用！）
}
void test()
{
  int x = "占内存变量1";
  int y = "占内存变量2";
  int z = "占内存变量3";
}
int main()
{
  // result在这里引用了一个局部变量
  int& result = sum();
  test();    // 调用其他函数，注意这里会分配内存，有可能会分配到将局部变量引用释放掉后的内存
  cout << "result = " << result << endl;
  return 0;
}
```

#### **函数返回引用类型建议：** 
- 1、将返回类型修改为const int&
    const int& sum(int& num){……}
- 2、const类型为不可修改的左值，sum(num) = 1024 将函数再赋值时将不合法，编译不通过；
- 3、省略const会使函数的含义更加模糊，建议避免在设计函数中存在模糊的情况，因为模糊会增加犯错误的机会，应尽量避免犯错。
    const int& sum(const int& num){……}


#### **使用引用参数的一些指导原则：** 
- 1、能够修改调用函数中的数据对象；
- 2、数据对象较大时传递引用可以提高程序运行效率；
    - 2.1 函数中不需要修改传递的参数：
      - 如果数据对象很小，建议按值传递；
      - 传递数组只能使用指针，并使用const关键字；
      - 较大的对象则使用const指针或引用，以提高程序的效率。
      
    - 2.2 函数中需要修改传递的参数时：
      - 数据对象是基本类型或结构时，可以使用指针或引用（基本类型建议使用指针）；
      - 数据对象是数组时只能使用指针；
      - 数据对象是类对象时，要求使用引用。

### 默认参数
&emsp;&emsp;在函数声明时默认赋初始值，如下：
#### **使用默认参数注意：** 
- 1、默认值可以在函数原型**或者** 定义中给出，**不能在这两个位置同时出现！** 
- 2、对于带参数列表的函数，必须**从右向左** 添加默认值。
    void test1(int a, int b = 5, int c = 10);    // 正确! test1(1); | test1(1, 2);
    void test2(int a, int b = 5, int c);        // 错误！ 默认参数后的参数int c也必须有默认值！
    void test3(int a = 1, int b = 5, int c = 10); // 正确！ test3(); | test3(1); | test3(1, 2);

```C
void sample(int = 100);
int main()
{
    sample();
    sample(123);
    return 0;
}

void sample(int num)
{
  cout << num << endl;
}
```

### 函数重载（重点）
&emsp;&emsp;函数重载（overloading）:1、指可以有多个同名的函数；2、函数名相同，参数列表不同（特征标不同）。
#### **函数重载注意：** 
- 1、从编译器的角度看，Swap(int)和Swap(int&)的特征标是相同的，调用时都可以写作：Swap(123)，为避免混乱，编译器把类型引用和类型本身视为同一个特征标。
- 2、调用匹配函数时，不区分const和非const变量。

其中：特征标，重载-编译器在编译时，根据参数列表对函数进行重命名，如下：
```C
void Swap(int a, int b);
根据特征标，编译器会重命名函数为：Swap_int_int

void Swap(float a, float b);
根据特征标，编译器会重命名函数为：Swap_float_float

有歧义时，编译器【重载决议】，来决定调用不同的函数：Swap_int_int
void Swap(int& a, int& b)
根据特征标，编译器会重命名函数为：Swap_int_int

```


### 函数模板（难点）
&emsp;&emsp;





### 类的声明
- 使用class / struct关键字声明类型；
    - class 类名{};
    - struct 类名{};
- 注意：
  - 1、class方式声明的类型与struct声明的类型仅仅是形式上不同；
  - 2、其唯一的区别在于使用class声明的类型默认成员是**私有的（private）**，而struct声明的类型默认成员是**公有的（public）。** 



#### 作用域解析运算符
::

返回类型 类名::函数名(){
    // 函数执行语句
}


#### 访问修饰符


#### 构造函数
1、定义：
- 以类名作为函数名
- 无返回值类型

2、作用：
- 初始化对象的数据成员
- 类对象被创建时，编译器为对象分配内存空间并自动调用构造函数以完成成员的初始化

3、构造函数的种类
- 无参构造（默认构造）
- 一般构造（重载构造）
- 拷贝构造

4、注意：
- 4.1 如果创建的类中未书写任何构造函数，系统会自动生成默认的无参构造函数（函数为空，什么都不做）
- 4.2 如果书写了构造函数，系统就不会再自动生成默认构造；如果希望有一个这样的无参构造函数，需要自己**显示**地书写出来


#### 带参构造
&emsp;&emsp;
pass


### 堆与栈内存详解
&emsp;&emsp;
栈内存（存放基本数据类型：整型、float、double型、字符型、对象句柄等）：栈里内存共享，容量小，不能将所有数据都放栈内存；（多个函数栈）


栈内存：类似于宜家展览区，根据物品取货码去仓库（堆内存）提货；
堆内存：类似于家具仓库；全局数据区；

### 使用类创建对象
